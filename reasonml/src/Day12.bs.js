// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var $$String = require("bs-platform/lib/js/string.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");

function createPatternMap(inputs) {
  var inputPattern = (/([\.#]{5}) => ([\.#])/);
  var matchInput = function (param) {
    return Caml_option.null_to_opt(param.match(inputPattern));
  };
  var matchedToTuple = function (matched) {
    if (matched !== undefined) {
      var match = matched;
      if (match.length !== 3) {
        return undefined;
      } else {
        var p = match[1];
        var v = match[2];
        return /* tuple */[
                p,
                v
              ];
      }
    }
    
  };
  return Belt_MapString.fromArray(Belt_Array.map(Belt_Array.keep(Belt_Array.map(Belt_Array.map(inputs, matchInput), matchedToTuple), Belt_Option.isSome), Belt_Option.getExn));
}

function createGeneration(initialState) {
  return /* record */[
          /* state */initialState,
          /* startIndex */0
        ];
}

function sumOfPotNumbers(param) {
  var startIndex = param[/* startIndex */1];
  return Belt_Array.reduce(Belt_Array.mapWithIndex(param[/* state */0].split(""), (function (index, $$char) {
                    var match = $$char === "#";
                    if (match) {
                      return index + startIndex | 0;
                    } else {
                      return 0;
                    }
                  })), 0, (function (sum, n) {
                return sum + n | 0;
              }));
}

function getPattern(state, index) {
  var paddedState = "....." + (state + ".....");
  if (index >= -3 && index <= (state.length + 2 | 0)) {
    return $$String.sub(paddedState, index + 3 | 0, 5);
  } else {
    return "";
  }
}

function evolve(patternMap, param) {
  var state = param[/* state */0];
  var newGeneration = Belt_Array.map(Belt_Array.map(Belt_Array.range(-3, state.length + 2 | 0), (function (param) {
                return getPattern(state, param);
              })), (function (__x) {
            return Belt_MapString.getWithDefault(patternMap, __x, ".");
          })).join("");
  var nonEmptyHeadPos = newGeneration.indexOf("#");
  var nonEmptyTailPos = newGeneration.lastIndexOf("#");
  return /* record */[
          /* state */newGeneration.substring(nonEmptyHeadPos, nonEmptyTailPos + 1 | 0),
          /* startIndex */(param[/* startIndex */1] - 3 | 0) + nonEmptyHeadPos | 0
        ];
}

function simulate(initialState, patternInputs, totalGeneration) {
  var generation = /* record */[
    /* state */initialState,
    /* startIndex */0
  ];
  var patternMap = createPatternMap(patternInputs);
  for(var _gen = 1; _gen <= totalGeneration; ++_gen){
    var newGeneration = evolve(patternMap, generation);
    generation = newGeneration;
  }
  return generation;
}

exports.createPatternMap = createPatternMap;
exports.createGeneration = createGeneration;
exports.sumOfPotNumbers = sumOfPotNumbers;
exports.getPattern = getPattern;
exports.evolve = evolve;
exports.simulate = simulate;
/* No side effect */
